"""
1. Выбрать дз, к функциям которого надо писать тесты (например, вебинар 5);
2. Создать дополнительную ветку в репозитории GitHub с тестами;
3. Написать не менее 5-ти тестов к функциям выбранного урока;
4. В качестве ответа на дз прислать ссылку на ветку с тестами или ссылку на
   PullRequest ветки с тестами с веткой master.

Важно! перед выполнением функции, которая вызывается из main, в модуле light
ВЫПОЛНЯЕТСЯ весь код, который располагается ВЫШЕ этой функции.
При этом не обязательно из этого кода лепить функцию
(что в конце концов и было сделано). И если весь код размещён по функциям,
тогда появляются дополнительные (стандартные) возможности
управления выполнением этого кода.

 Автоматизированное Тестирование vs. Ручное Тестирование
Уже БЫЛИ тесты хотя бы при создании этого приложения
Первые запуски вариантов приложения и его применение.
Проверка функций и эксперименты с ними. Эта деятельность называется
исследовательским тестированием, и оно является разновидностью ручного тестирования.

Исследовательское тестирование — тестирование, которое проводится без плана.
Во время исследовательского тестирования исследуется приложение.

Чтобы создать полный список мануальных тестов, достаточно составить перечень
всех функций приложения, различных типов ввода, которые оно принимает,
и ожидаемые результаты.
Теперь, каждый раз когда меняется что-то в коде, нужно заново проверять каждый из
элементов этого списка.

Это беда...
Поэтому нужны автоматические тесты.
Автоматическое тестирование — выполнение плана тестирования
(части приложения, требующие тестирования,
 порядок их тестирования и
 ожидаемые результаты) с помощью скрипта, а не руками.
 В Python уже есть набор инструментов и библиотек, которые помогают создать
 автоматизированные тесты для приложения.

"""

# применение модулей из из разных пакетов в одном приложении.
# При разработке применяется тестирование о отладка, что и видно во
# множестве комментариев к коду.

import importlib.util
from sys import path

# Ипорт модуля victoryPack должен быть произведён ПОЗЖЕ
# from victoryPack import *

"""
Утилиты поиска и загрузки модуля...
Модуль importlib.util содержит различные объекты, которые помогают в создании объекта, 
который находит и загружает модуль.

Импорт из другого каталога 
Если Импортируемый скрипт находится в том же каталоге, то можно его импортировать так же, 
как и встроенные модули. Если скрипт присутствует в другом каталоге, можно 
использовать библиотеку importlib, чтобы импортировать его как модуль.

Проверка возможности импорта модуля:
Если нужно выяснить, можно ли импортировать модуль без фактического импорта, 
следует использовать importlib.util.find_spec ().

"""

def playGame(mmm, TheBornExpert):
# объект меню-машина ссылка на объект TheBornExpert
    print('::::::::::')

    print(f'TheBornExpert: {TheBornExpert}')

    while True:

        mmm.get('qm')
        print(f'меню-машина получает {mmm.qm} of quizQuantity')

        #TheBornExpert(mmm.qm)  # так результаты работы TheBornExpert
                                # будут НАКАПЛИВАТЬСЯ
        bex = TheBornExpert(mmm.qm)
        print(f'bex: {bex}') # ссылка на результат работы TheBornExpert как он есть.
                             # И он меняется (!!!) от значения quizQuantity
        # bex - это ссылка на результат работы TheBornExpert с аргументом mmm.qm .
        # под это значение mmm.qm объект TheBornExpert настраивает и проводит игру.

        mmm.get('go')
        print('меню-машина получает запрос на продолжение игры')

        # и если это 'no', то игра прекращается
        if mmm.go == 'no':
            break
        else:
            # Значение ссылки bex МЕНЯЕТСЯ.
            # Поэтому объект по этой ссылке bex
            # надо удалять. И тогда значение ссылки
            # не будет меняться во время игры.
            del(bex)

    print('::::::::::')

# ========================================================================
# хорошая функция для импорта модуля из файла, но можно обойтись без неё
# и сделать всё более 'простым' (ну да, ну да...) способом. ==============
def module_from_file(module_name, file_path):
    # importlib.util.spec_from_file_location(name,
    #                                        location,
    #                                         *,
    #                                         loader=None,
    #                                         submodule_search_locations=None):
    # Функция предназначена для создания объекта класса
    # importlib.machinery.ModuleSpec() на основе пути к файлу.
    spec = importlib.util.spec_from_file_location(module_name, file_path)

    # importlib.util.module_from_spec(spec):
    # Функция importlib.util.module_from_spec создает новый модуль на основе
    # spec и spec.loader.create_module.
    # Если spec.loader.create_module не возвращает None, то любые ранее существующие
    # атрибуты не будут сброшены. Кроме того, никакой AttributeError не будет вызван,
    # если вызван, обращаясь к спецификации или устанавливая атрибут в модуле.
    # Для создания нового модуля эта функция предпочтительнее, чем использование
    # types.ModuleType, т.к. для установки максимально возможного количества
    # контролируемых импортом атрибутов в модуле используется спецификация.
    module = importlib.util.module_from_spec(spec) # новый модуль

    # подключение Python-модуля по абсолютному пути.
    # Модули, используемые в скриптах, располагаются или в той же директории,
    # что и сам скрипт, или в директории установки пути "версия_blender\python\lib\".
    # Однако возможно подключить для работы и модуль, расположенный
    # в другом месте на диске.
    # Для этого нужно подключить модуль по его абсолютному пути.
    # Задаётся полный путь к директории модуля и имя, под которым модуль
    # будет подключен в API через переменные:
    #
    # path = 'd:\\dev\\python\\blender\\bpy_plus\\__init__.py'
    # name = 'bpy_plus'
    #
    # Далее модуль загружается при помощи importlib:
    #
    # import importlib
    # import sys
    #
    # spec = importlib.util.spec_from_file_location(name, path)
    # module = importlib.util.module_from_spec(spec)
    # sys.modules[spec.name] = module
    # spec.loader.exec_module(module)
    #
    # Теперь можно обращаться к загруженному модулю обычным образом,
    # через import по указанному имени. Например,так:
    #
    # from bpy_plus import about
    # print(about.version())
    #
    # exec_module(module)
    # Абстрактный метод, который выполняет модуль в его собственном
    # пространстве имен, когда модуль импортируется или перезагружается.
    spec.loader.exec_module(module)
    return module
# ========================================================================

# module_from_file для импорта menuMashine, который находится в ДРУГОМ каталоге.
# В каталоге ../test_31_05_2023, модуле menuMashine.py
#main = module_from_file("main", "../test_31_05_2023/menuMashine.py") # <<<<<
#menuMashine = module_from_file("menuMashine", "../test_31_05_2023/menuMashine.py") # <<<<<
#                                  имя модуля         путь к файлу
# Однако далее она не применяется ========================================


def doIt():
    print(f'path: {path}') # это РЕАЛЬНО sys.path как она есть. Список строк со всякими путями,
                           # которые важны при работе с модулями. Первые два элемента
                           # этого списка строк идентичны.
    # Это важно, так как предстоит работа с модулями из другого каталога
    # и значение sys.path надо изменять !!!

    # функции: Импорт из модуля. Имеется в виду другой каталог, а не тот, из которого
    # запускалась выполняемая программа. Здесь настраивается sys.path. Вроде можно было
    # бы изменить ТОЛЬКО первый элемент sys.path. А потом вторым элементом списка
    # пользоваться при восстановлении старого состояния sys.path.
    # Адрес текущего и используемого каталогов ВСЕГДА знать надо!

    # module_from_file для импорта menuMashine, который находится в ДРУГОМ каталоге.
    # В каталоге ../test_31_05_2023, модуле menuMashine.py
    # main = module_from_file("main", "../test_31_05_2023/menuMashine.py") # <<<<<
    # menuMashine = module_from_file("menuMashine", "../test_31_05_2023/menuMashine.py") # <<<<<
    #                                  имя модуля         путь к файлу
    # Однако далее она не применяется ========================================

    # вот характеристики импортируемых с module_from_file модулей.
    #print('==========')
    #print(main)
    #print(menuMashine)
    #print('==========')

    # Настройка под каталог с приложением Tests_2022\\test_31_05_2023:
    # для ДВУХ элементов в sys.path меняется значение на новое, которое соответствует
    # каталогу в котором расположены модули.
    path[0] = 'C:\\PythonDrom\\Tests_2022\\test_31_05_2023'
    path[1] = 'C:\\PythonDrom\\Tests_2022\\test_31_05_2023'

    # Модули main и menuMashine ранее уже могли быть импортированы с помощью функции
    # module_from_file БЕЗ предварительной настройки каталога.
    # И всё же теперь теперь эти модули импортируются функцией importlib.import_module
    # ПОСЛЕ настройки каталога. Вроде так нагляднее.

    # Это демонстрация работы функции __import__ =========================
    # print('::::::::::')
    #main = __import__('main', globals=None, locals=None, fromlist=['main'])
    # print(main)
    # # <module 'main' from 'C:\\PythonDrom\\Tests_2022\\test_31_05_2023\\main.py'>
    #
    #menuMashine = __import__('menuMashine', globals=None, locals=None, fromlist=['menuMashine'])
    # print(menuMashine)
    # # <module 'menuMashine' from 'C:\\PythonDrom\\Tests_2022\\test_31_05_2023\\menuMashine.py'>
    # print('::::::::::')
    # ====================================================================

    main = importlib.import_module('main', '../test_31_05_2023/main.py')
    menuMashine = importlib.import_module('menuMashine', '../test_31_05_2023/main.py')

    print('__________')
    print(main)
    print(menuMashine)

    # ДЛЯ модулей '../test_31_05_2023/main.py' и '../test_31_05_2023/menuMashine.py'
    # импортируются модули из '../test_12_07_2023/victoryPack'

    #from victoryPack import *  # здесь важно правильно импортировать модули!
    from victoryPack import xVictory
    from victoryPack import bornExpert
    # РАНЬШЕ было бы рано - не было бы понятно, для кого предназначен
    # 'местный' victoryPack, на котором обеспечивается тестирование модуля.
    # И вообще, import * only allowed at module level (???).
    # Но импорт (раздельный) модулей всё же получился.
    # Корректные инструкции импорта модулей позволили собрать из
    # всего этого кода функцию doIt(), вызовом которой МОЖНО управлять,
    # а не ждать выполнения отдельных операторов.
    # И если придется импортировать модули в теле функции или внутри класса,
    # то следует иметь в виду, что все переменные модуля будут импортированы
    # либо в локальную область видимости функции, либо в дерево атрибутов
    # класса.
    # Желательно избегать инструкций import в теле функции, т.к. это может
    # приводить к многократным ДОРОГОСТОЯЩИМ операциям импортирования
    # при каждом новом вызове функции в виду очистки памяти после выхода из нее.
    # Именно из-за дороговизны импорта любой дополнительный модуль по умолчанию
    # подгружается только один раз за все время работы программы.
    # При повторных попытках импорта интерпретатор по умолчанию просто
    # использует модуль, уже загруженный в память. =======================

    # пошли запуски функций загруженных модулей. =========================
    # !!! ВАЖНО !!! В процессе работы с Python иногда возникает ошибка
    # "TypeError: 'module' object is not callable". Эта ошибка обычно происходит,
    # когда разработчик пытается вызвать модуль, как функцию. Модуль НЕ ВЫЗЫВАЕТСЯ.
    # ВЫЗЫВАЮТСЯ функции и методы, объявленные в модуле. =================

    xVictory.sayHello_0(f'\nhello from victoryPack\n')
    bornExpert.sayHello_0(f'12345\n')
    xVictory.BornExpertInitor.helloFromBornExpertInitor()
    bornExpert.TheBornExpert.helloFromBornExpert()

    # импорт модуля menuMashine был ранее произведён функцией module_from_file.
    mmm = menuMashine.MenuMashine()     # меню машина привинчена снаружи приложения.
                                        # mmm - это её объект.

    print(mmm) # характеристики объекта menuMashine.MenuMashine.
               # Объявление класса для этого объекта в каталоге '../test_31_05_2023'

    print('~~~~~~~~~~')

    # вот сама игра! С привлечением модулей из разных каталогов...

    playGame(mmm, bornExpert.TheBornExpert)  # функция вместо кода игры
    # объект меню-машина ссылка на объект TheBornExpert
    # print('::::::::::')
    # while True:
    #     mmm.get('qm')
    #     bex = bornExpert.TheBornExpert(mmm.qm)
    #     del bex
    #     mmm.get('go')
    #     if mmm.go == 'no':
    #         break
    # print('::::::::::')

    # конец игры

    print('++++++++++++++++++++++++++++++++')

    print(path)     # модифицированный path

    print(__doc__)  # описание модуля light.py
    print(__file__) # каталог модуля
    print(__name__) # имя модуля

    # ручное восстановление списка sys.path
    path[0] = 'C:\\PythonDrom\\Tests_2022\\test_12_07_2023'
    path[1] = 'C:\\PythonDrom\\Tests_2022\\test_12_07_2023'

    print(path)
    print('++++++++++++++++++++++++++++++++')

# с восстановленным path из main возможен вызов функции light.start('0_light_task')
def start(descrption):
    print(f'light start {descrption}\n')
    doIt()

# Здесь также действует соглашение о запуске функций при условии
# соответствия имени модуля значению переменной __name__.
# То есть, сначала будет ТРИ раза выполнена функция start,
# затем doIt, а только ПОТОМ - вызовы, которые приходят из main.
# так что в случае с вызовом функций из модулей, которые
# НЕ являются главными этого соглашения не применять во избежание
# нарущений порядка вызова функций
# if __name__ == 'light':
#     start(f'light__1__\n')
#     start(f'light__2__\n')
#     start(f'light__3__\n')
#     doIt()



