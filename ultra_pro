"""
1. Выполнить задание уровня pro
2. В проекте из прошлого домашнего задания создать новый модуль test_ultrapro.py
3. В модуле написать тесты для встроенных функций filter, map, sorted,
   а также для функций из библиотеки math: pi, sqrt, pow, hypot.
   Чем больше тестов на каждую функцию - тем лучше

Можно узнать, как создать базовый тест, выполнить его и найти все баги,
до того как они сами не проявились! Какие доступные инструменты для написания
и выполнения тестов, проверка производительности приложения и посмотреть на
проблемы безопасности.
Тестировать код можно разными способами. С методами от самых простых до самых продвинутых.

Кстати, есть REPL. Это встроенная в Python программа,  которая работает как командная оболочка.
Программу REPL еще называют интерактивным интерпретатором Python.
Эта программа предназначена для ввода и выполнения кода на языке Python.
Для запуска REPL достаточно набрать python3. После этого можно выполнять код на Python и
смотреть на результат его выполнения. REPL выводит результат выполнения операции прямо на экран
и снова входит в режим ожидания ввода команд.
Такой способ работы хорошо подходит для отладки, простых вычислений и быстрой проверки гипотез.
В REPL разные начала строчек:
Строки с >>> — это код, введенный программистом. Сам символ >>> называется приглашением
Строки без >>> — это результат выполнения введенного кода
Само приглашение вводить не надо — достаточно ввести только сам код, следующий за символами >>>.
Как REPL отображает возврат из функции значения None.
Никак, и это сделано специально. Если функция не возвращает результат явно, считается,
что она возвращает None. И чтобы не загромождать вывод REPL бесконечными None, вывод
этого значения блокируется интерпретатором.
В Python REPL можно вводить и многострочный код. Отредактировать уже введенные строчки при этом не получится.
Зато можно вводить таким способом небольшие функции.
Если вводится строчка, которая по смыслу еще не завершилась, REPL меняет приглашение >>> на ...
и ожидает ввода новой строчки в дополнение к уже введенной.
Так можно ввести целое определение функции вместе с docstring и логикой.
Окончанием ввода всего многострочного кода служит пустая строчка
поэтому в коде не получится использовать пустые строчки.

Автоматизированное vs. Ручное Тестирование
Первые запуски приложения и их применение - уже тестирование.
Функция проверена и с ней произведены всякие эксперименты. Такой процесс называется
исследовательским тестированием, и он является формой ручного тестирования.
Исследовательское тестирование — тестирование, которое проводится без плана.
Во время исследовательского тестирования исследуется приложение.
Чтобы создать полный список мануальных тестов, достаточно составить список всех функций
приложения, различных типов ввода, которые оно принимает, и ожидаемые результаты.
Теперь, каждый раз когда что-меняется в коде, нужно заново проверять каждый из элементов
этого списка.
Это сложно. Но есть автоматические тесты. Автоматическое тестирование — это исполнение
плана тестирования (части приложения, требующие тестирования, порядок их тестирования
и ожидаемые результаты) с помощью скрипта, а не средствами ручного тестирования.
В Python уже есть набор инструментов и библиотек, которые помогут создать автоматизированные
тесты для приложения.

 Модульные Тесты vs. Интеграционные Тесты
Много терминов, и теперь, зная разницу между ручным и автоматизированным тестированием,
можно продвинуться дальше.
Как, например, можно протестировать фары машины?
Включить фары (это ШАГ тестирования), выйти из авто или попросить кого-то,
чтобы проверить, что фары зажглись (это — ТЕСТОВОЕ СУЖДЕНИЕ).
Тестирование нескольких компонентов называется ИНТЕГРАЦИОННЫМ ТЕСТИРОВАНИЕМ.
Надо подумать о всех вещах, которые должны правильно работать, чтобы простая
задача выдала корректный результат. Перегорела лампочка (?). Проводка (?).
Проблемы с генератором (?). Или сбой в бортовом компьютере(???) машины.
Современные(???) машины сами оповестят о поломке лампочек. Это определяется с помощью
модульного теста.
Модульный тест (юнит-тест) — НЕБОЛЬШОЙ тест, проверяющий корректность работы
отдельного компонента. Модульный тест помогает изолировать поломку и быстрее ее устранить.

Эти компоненты похожи на части тестируемого приложения: все те классы, функции, модули,
что были написаны.

Таком образом, имеют место два вида тестов:
Интеграционный тест, проверяющий компоненты системы и их взаимодействие друг с другом;
Модульный тест, проверяющий отдельный компонент приложения.

Оба теста можно создать на Python. Например, чтобы написать тест для
встроенной функции sum(), нужно сравнить выходные данные sum() с известными значениями.

==========================================================================
Функциональное программирование обычно использует списки, массивы и другие
итерационные объекты для представления данных вместе с набором функций,
которые работают с этими данными и преобразовывают их.
Когда дело доходит до обработки данных в функциональном стиле,
обычно используются как минимум три метода:

= Сопоставление (Mapping) заключается в применении функции преобразования к итерируемому
  объекту для создания нового объекта. Элементы в новой итерации создаются путем вызова
  функции преобразования для каждого элемента в исходной итерации.
= Фильтрация (Filtering) состоит из применения предиката или булевозначной(!!!) функции
  (predicate or Boolean-valued function) к итерируемому объекту для создания нового
  итерируемого объекта. Элементы в новой итерации создаются путем фильтрации любых элементов
  в исходной итерации, которые заставляют функцию предиката возвращать false.
= Сокращение (Reducing) состоит из применения функции reduce к итерируемому объекту для
  получения единственного накопленного значения.

Встроенные map, filter, reduce ================================================
Встроенные функции высшего порядка (ФВП) map, filter и reduce являются важными инструментами
в python для обработки коллекций данных.
Эти функции (ФВП) позволяют применять к элементам коллекции функции-аргументы и получать
новые значения.

Обработка коллекций данных в python с использованием встроенных функций map, filter и reduce
для получения новых данных.

functools.reduce ==============================================================
Чтобы использовать функцию reduce, необходимо импортировать ее из встроенного модуля functools,
который содержит функции высшего порядка (ФВП).
Объявление функции reduce :

from functools import reduce

reduce(function, sequence[, initial]) -> value

Передаваемые ей аргументы:

function — функция, которая будет применена к элементам коллекции для их объединения
sequence — коллекция данных, которую нужно объединить
initial (опционально) — начальное значение аккумулятора, которое будет использовано
        в качестве первого аргумента при объединении

Если аргумент initial не указывается, то функция reduce будет использовать в качестве
начального значения первый элемент передаваемой коллекции sequence.
Если коллекция пустая, то вызов reduce завершится с ошибкой (возбуждение исключения).

===============================================================================
Пример работы функции functools.reduce:

from functools import reduce

numbers = [2, 3, 8]

def get_maximum(first_num, second_num):
    return first_num if first_num > second_num else second_num

reduce(get_maximum, numbers, 10)  # 10
reduce(get_maximum, numbers)  # 8

Если указано начальное значение аккумулятора 10, то результат будет 10,
так как это число больше всех элементов в коллекции. Если начальное значение не указано,
то reduce использует первый элемент в коллекции numbers в качестве начального значения
и возвращает максимальный элемент в коллекции.

Функция, которая передается в качестве первого аргумента в reduce,
должна принимать два аргумента и возвращать одно значение.
При использовании reduce нужно убедиться, что передаваемая функция ассоциативна,
то есть, не зависит от порядка применения и может быть применена в любом порядке.

===============================================================================
filter
Теперь filter:

filter(function or None, iterable) -> filter object
None в роли предиката — это замена для условия "всё что угодно, лишь бы было истинно".
Тот же результат даст фильтрация с bool в качестве предиката.

Возвращаемое значение filter object — это не список, ЭТО итератор.
То есть это встроенный filter. Это ленивый фильтр.
Он возвращает элементы по одному, если находит подходящие.

Пример работы функции filter:

numbers = [2, 3, 8, 15, 34, 42]

def is_even(num):
    return num % 2 == 0

filter(is_even, numbers)  # <filter object at ...>
list(filter(is_even, numbers))  # [2, 8, 34, 42]

Здесь функция is_even проверяет, является ли число четным, и возвращает True или False
в зависимости от этого.
Функция filter возвращает итератор, возвращающий только те элементы коллекции numbers,
для которых предикат (функция-предикат) is_even возвращает True.

Функция, которая передается в качестве первого аргумента в filter, должна принимать
один аргумент и возвращать значение True или False.
При использовании filter нужно убедиться, что предикат корректно определен и возвращает
ожидаемый результат для каждого элемента коллекции.

Также важно, что filter возвращает ленивый итератор.
И чтобы получить все элементы, необходимо явно преобразовать его в список
или другой тип коллекции.

===============================================================================
map
Теперь map:

map(func, *iterables) --> map object

Здесь map object — тоже итератор. А аргумент *iterables принимает несколько итерируемых
объектов вместо одного.
Если map передать более одного источника элементов, то функция func будет вызвана сначала
для всех первых элементов, а потом для остальных. И так будет продолжаться, пока
не закончатся элементы хотя бы в одном источнике.
map применяет произвольную функцию — от соответствующего числу источников количества аргументов.

Вот пример применения функции map к паре источников:

from operator import mul
map(mul, "abc", [3, 5, 7])  # <map object at ...>
list(map(mul, "abc", [3, 5, 7]))  # ['aaa', 'bbbbb', 'ccccccc']

Здесь в качестве первого аргумента функции map передаётся функция mul из модуля operator.
mul — это функция, которая принимает два аргумента и возвращает их произведение.

Функция map вернула итератор, который затем с помощью функции list преобразуется в список.
Результатом выполнения функции map является список строк, полученный умножением каждой буквы
из "abc" на соответствующее число из [3, 5, 7].

Здесь используется *iterables, чтобы передать несколько итерируемых объектов в map.

===============================================================================
map, filter, reduce и побочные эффекты
Когда используются встроенные функции высшего порядка (ФВП), следует руководствоваться
следующим правилом:
применяемые с их помощью функции по возможности должны быть чистыми.

Например, использование побочных эффектов вместе с функцией map плохо тем,
что функция возвращает ленивый итератор. Значит, эффекты будут происходить не при вызове,
а когда объекты будут потребляться.
К тому же побочные эффекты нарушают законы, которые характерны для математических
версий map, filter и reduce:

- Ассоциативность — результат применения функции не зависит от порядка применения.
  Например, (f * g) * h равносильно f * (g * h)
- Нейтральный элемент — существует такой элемент, при применении функции к которому
  результат не изменится. Например, для операции умножения этот элемент равен единице
- Дистрибутивность — результат применения функции к объединению двух множеств
  равен объединению результатов применения функции к каждому из множеств отдельно.
  Например, f(S1 | S2) = f(S1) | f(S2)
- Коммутативность — результат не зависит от порядка аргументов.
  Например, f(x, y) = f(y, x)

Если используются побочные эффекты в функциях map, filter и reduce,
то можно нарушить эти свойства и получить непредсказуемый результат.
Например, если использовать print в функции map, то порядок элементов в выводе
может не соответствовать порядку элементов в исходной последовательности,
что нарушает коммутативность.

Пример с нарушением ассоциативности:

from functools import reduce

def add(x, y):
    print(f"Adding {x} and {y}")
    return x + y

numbers = [1, 2, 3, 4, 2]

result = reduce(add, map(lambda x: x * 2, filter(lambda x: x % 2 == 0, numbers)))

# Adding 4 and 8
# Adding 12 and 4
# 16

Здесь был использован побочный эффект print в функции add, вызываемой внутри reduce.
Так порядок вызовов функции add зависит от порядка обхода элементов в итераторах
map и filter, что нарушает ассоциативность.

===============================================================================
reduce, map и filter и грязные функции
 Использование грязных функций с reduce, map и filter.

Грязные функции и reduce ======================================================
Когда функции с побочными эффектами используются для правой и левой сверток,
перестает работать равенство результата.
В этом случае левая свертка будет производить эффекты для элементов по порядку,
а правая — с конца к началу. ==================================================

Если возвращаемый из функции результат создется, ОБЩИЙ НАБЛЮДАЕМЫЙ ЭФФЕКТ, например,
порядок записанных в файл строк, будет отличаться.

Грязные функции и map =========================================================
Если взять грязную функцию, то для map нарушится закон:

map(f, map(g, l)) == map(f*g, l).

Здесь в виде f*g записана композиция функций — получение функции,
делающей x -> f(g(x)).
Встроенного оператора для композиции в Python НЕТ!, но ФУНКЦИЮ КОМПОЗИЦИИ можно
определить так:

def compose(f, g):
    return lambda x: f(g(x))

Этот закон важен, так как позволяет произвести оптимизацию — превратить два прохода
по последовательности в один. При использовании же функции с эффектами, программа до
оптимизации и после нее будет работать по-разному.
Например, до оптимизации будут выполнены сначала все эффекты функции g,
потом — эффекты функции f.
А после оптимизации эффекты g и f будут происходить парами.

Грязные функции и filter ======================================================
Для filter возможна такая оптимизация:

filter(f, filter(g, l)) == filter(g&f, l)

Здесь g&f — это условное обозначение функции, которая делает x -> g(x) and f(x).
Такого оператора в Python НЕТ!, но можно реализовать подобную функцию так:

def filter_compose(f, g):
    return lambda x: filter(f, filter(g, x))

В случае filter после оптимизации эффекты тоже перемещаются,
как было описано выше для функции map.

Правило работы с ФВП (Функции Высшего Порядка) ================================
Если видно, что в ФВП просится не чистая функция — надо переписывать на цикл.
Цикл в python мощный, и в его теле может происходить что угодно.
Поэтому пусть и эффекты происходят в цикле, а не в чистых map, filter и reduce.

Оптимизация согласно законам конкретно во встроенных функциях может и не делаться.
Но можно встретить или реализовать библиотеку, в которой подобные оптимизации будут
возможны. Потом окажется, что сходу понять, почему код после оптимизации работает
именно так, практически невозможно.
А функции map, filter и reduce как раз и нужны, чтобы упрощать понимание логики.

Выводы ========================================================================
Встроенные функции высшего порядка — это мощный инструмент для работы с
коллекциями данных в Python. Они позволяют сократить количество кода и упростить
его понимание, а также сделать код более читаемым и модульным.
map, filter и reduce позволяют производить операции над итерируемыми объектами
с помощью применения к ним заданных функций. Функции могут быть переданы как
аргументы, что позволяет увеличить гибкость кода и переиспользовать функции.

"""
import math
import random
import unittest


# В исключениях, которые возникают в результате unittest тестирования в
# к ачестве обработчика исключений можно было бы применить механизм
# with self.assertRaises(Exception) as context:
#     broken_function()
# , однако более наглядным представляется обычный обработчик исключений

# def broken_function():
#     raise Exception("error")

class TestSum(unittest.TestCase):
    arg1 = []
    arg2 = 0
    errorMessage = ''

    def go(self):

        self.test_sum_0()

        TestSum.arg1 = [1, 2, 3]
        TestSum.arg2 = 9
        self.test_sum_1()

        TestSum.arg1 = [1, 2, 5]
        TestSum.arg2 = 9
        TestSum.errorMessage = "Should be 5"
        self.test_sum_tuple_0()

        TestSum.arg1 = [1, 2, 3]
        TestSum.arg2 = 6
        self.test_sum_X()

    # ====================================================================

    def test_sum_0(self):
        print('\ntest_sum_0')
        try:
            self.assertEqual(sum([1, 2, 3]), 6, "test_sum_0")
        except Exception as ex:
            print(ex)
        else:
            print("OK, test_sum_0 passed")

        # with self.assertRaises(Exception) as context:
        #     broken_function()

    def test_sum_1(self):
        print('\ntest_sum_1')
        try:
            self.assertEqual(sum(TestSum.arg1), TestSum.arg2, "test_sum_1")
        except Exception as ex:
            print(ex)
        else:
            print("OK, test_sum_1 passed")

        # with self.assertRaises(Exception) as context:
        #     broken_function()

    def test_sum_tuple_0(self):
        print('\ntest_sum_tuple_0')
        try:
            self.assertEqual(sum((1, 2, 2)), 9, TestSum.errorMessage)
        except Exception as ex:
            print(ex)
        else:
            print("OK, test_sum_tuple_0 passed")

        # with self.assertRaises(Exception) as context:
        #     broken_function()

    # на этой функции отрабатывались способы передачи аргументов в функции.
    # Как оказалось, здесь не всё так просто.
    def test_sum_X(self):

        print('\ntest_sum_X')
        try:
            self.assertEqual(sum(TestSum.arg1), TestSum.arg2, "test_sum_X")
        except Exception as ex:
            print(ex)
        else:
            print("OK, test_sum_X passed")

        # with self.assertRaises(Exception) as context:
        #     broken_function()

# =============================================================================
class FunTests(unittest.TestCase):
    data_a = []

    def go(self):

        FunTests.data_a = list(range(1, 11))
        self.testFilter()

        FunTests.data_a = []
        FunTests.data_a = ['1', '2', '3', '5', '7']
        self.testMap()

        FunTests.data_a = []
        for i in range(0, 9):
            FunTests.data_a.append(random.randint(2, 15))
        self.testPowers()

    def testFilter(self):

        try:
            self.assertEqual(list(filter(lambda x: x % 2 == 0, FunTests.data_a)),
                             list(range(2, 12, 2)),
                             "filter is not correct")
        except Exception as ex:
            print(ex)
        else:
            print("OK, testFilter passed")

    def testMap(self):
        # ??? здесь сравниваются ДВА списка, полученных из итераторов
        # а как сравнить непосредственно сами итераторы ???


        try:
            self.assertEqual((list(map(int, FunTests.data_a))),
                             list(int(x) for x in ['1', '2', '3', '5', '7']),
                             "map is not correct")

        except Exception as ex:
            print(ex)
        else:
            print("OK, testMap passed")

    def testPowers(self):
        # data_a = []
        # for i in range(0, 9):
        #     data_a.append(random.randint(2, 15))

        data_b = []
        data_c = []

        for x in FunTests.data_a: data_b.append(int(math.pow(x, 2)))
        for x in data_b: data_c.append(int(math.sqrt(x)))

        # если исходный список случайных значений эквивалентен результату
        # преобразования pow-sqrt, то testPowers пройден
        try:
            self.assertEqual(FunTests.data_a, data_c, "testPowers is not correct")
        except Exception as ex:
            print(ex)
        else:
            print("OK, testPowers passed")


def utt():
    # создаётся объект TestSum, из которого запускаются тестируемые методы
    ts = TestSum()
    ts.go()
    fts = FunTests()
    fts.go()


# ========================================================================

def funTest_0():
    # Это есть тест-кейс(тестовый случай), утверждение и точка входа. ====
    print(f"ultra_pro: funTest is here")
    lstArg = [1, 1, 1]

    assert sum(lstArg) == 3, 'Should be 3'
    print(f"sum([1,1,1]) == 3 : it's correct")
    # assert sum(lstArg) == 9, 'Should be 9'
    print('funTest0 passed')


def funTest_1():
    # Это есть тест-кейс(тестовый случай), утверждение и точка входа. ====
    print(f"ultra_pro: funTest is here")
    tupleArg = (1, 1, 1)

    assert sum(tupleArg) == 3, 'Should be 3'
    print(f"sum([1,1,1]) == 3 : it's correct")
    # assert sum(tupleArg) == 9, 'Should be 9'
    print('funTest_1 passed')

    # ====================================================================


def start(descrption):
    print(f'ultra pro start {descrption}\n')
    funTest_0()
    funTest_1()
    utt()

    # Такие тесты подойдут для простой проверки. А если код "покруче" и, возмоно,
    # ошибок побольше, то надо применять исполнители тестов (test runners).
    # Исполнитель тестов — особое приложение, спроектированное для проведение тестов,
    # проверки данных вывода и предоставления инструментов для отладки и
    # диагностики тестов и приложений. Существует множество исполнителей тестов:
    # unittest;
    # nose или nose2;
    # pytest.
    # Например, в стандартную библиотеку Python встроен unittest. Здесь применяется
    # исполнитель тестов unittest для тестирования тест-кейов.
    #
    # Важно выбрать "адекватный" исполнитель тестов (чёткого определения критерия адекватности)
    # НЕТ.
    # Применение unittest.
    # unittest встроен в стандартную библиотеку Python, начиная с версии 2.1.
    # В unittest есть тестовый фреймворк и исполнитель тестов. При написании и исполнении тестов
    # нужно соблюдать некоторые важные требования.
    #
    # unittest требует:
    #
    # 1. Помещать тесты в классы, как методы;
    # 2. Использовать специальные методы утверждения. Класс TestCase вместо обычного
    #    встроенного выражения assert.
    #
    # Для преобразования ранее написанных примеров funTest_0, funTest_0 в тест-кейс
    # unittest нужно:
    #
    # 1. Импортировать unittest из стандартной библиотеки;
    # 2. Создать класс (в данном случае, под названием TestSum), который будет
    #    наследовать класс TestCase;
    # 3. Сконвертировать тестовые функции в методы:
    #    - добавть self в качестве первого аргумента тестовой функции,
    #    - изменить операторы assert, добавив вместо этого вызов метода
    #    self.assertEqual() из базового класса TestCase.
    # 4. Далее создать объект - представитель ранее объявленного класса.
    # 5. На этом объекте гонять тестовые методы радоваться, что всё OK,
    #    если нет ошибок, либо ловить исключения.

    # Далее приводятся всякие рекомендации,
    # следуя которым, можно создать новый файл ntt.py с таким кодом:

# import unittest
#
# class TestSum(unittest.TestCase):
#
#     def test_sum(self):
#         self.assertEqual(sum([1, 2, 3]), 6, "Should be 6")
#
#     def test_sum_tuple(self):
#         self.assertEqual(sum((1, 2, 2)), 6, "Should be 6")
#
# if __name__ == '__main__':
#    unittest.main()

# Этот файл лишь заготовка. Общее указание пути разработки.
# Ерунда полная, но и на том спасибо.

# ========================================================================
# функция filter():
# filter(func, *iterables)
# служит для фильтрации (отбора) элементов указанного итерированного объекта.
# Если функция func возвращает для текущего значения элемента True,
# то он будет возвращен, а при False – отброшен. Например, если имеется список из
# целых чисел:

# a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#
# и надо из него выбрать только четные значения, для этого надо написать функцию
# filter(), следующим образом:
#
# b = filter(lambda x: x % 2 == 0, a)
# print(b)
#
# После запуска функции видно, что переменная b ссылается на объект filter.
# Это итератор, который можно перебрать с помощью функции next():
#
# print(next(b))
# print(next(b))
#
# В результате можно увидеть в консоли первые два четных значения из списка.
# Их все можно перебрать с помощью цикла for:
#
# for x in b:
#     print(x, end=" ")

# Или, можно сформировать новый список с помощью функции list():
#
# c = list(b)
# print(c)

# Или кортеж:
#
# c = tuple(b)
#
# Можно перебрать итератор любыми функциями и операторами, которые на это способны.
# Иногда алгоритм обработки текущего значения для фильтра может быть непростым
# и записать его в лямбда-функцию будет непросто. Нуапример, проверить, является ли
# число простым или нет (простым называется любое натуральное число, которое делится
# только на себя и на единицу). Такую проверку лучше вынести в отдельную функцию:
#
# def is_prime_number(x):
#     d = x-1
#     if d < 0:
#         return False
#
#     while d > 1:
#         if x % d == 0:
#             return False
#         d -= 1
#
#     return True
#
# А затем применить ее в filter():
#
# b = filter(prime_number, a)
#
# На выходе получаются только простые числа из списка.
# Конечно, это не самый лучший способ поиска простых чисел,
# но как пример функции для filter() вполне подходит.
#
# Функцию filter можно применять с любыми типами данных, например, строками.
# Пусть имеется такой кортеж:
#
# lst = ("Москва", "Марсель01", "Смоленск", "Тверь32", "London")
# b = filter(str.isalpha, lst)
#
# for x in b:
#     print(x)
#
# Далее вызывается метод строк isalpha(), который возвращает True,
# если в строке только буквенные символы.
# ========================================================================
# Функция map (функция класса mapping).
#
# Пример использования функции map() для преобразования строк чисел в обычные числа:
#
# b = map(int, ['1', '2', '3', '5', '7'])
#
# Первый аргумент - ссылка на функцию, которая будет последовательно применяться к каждому
# элементу списка,
# второй аргумент – список из СТРОК с числами.
# Вообще, вторым аргументом может быть любой итерируемый объект.
# На выходе функция map() возвращает итератор: то есть, переменная b – это итератор,
# который можно перебрать для преобразования строк в числа.
#
# Для итератора b вызывается функцию next():
#
# print(next(b))
# print(next(b))
#
# ... и наблюдаются первые два преобразованных значения.
# если к b применить next оператор for:
#
# for x in b:
#     print(x, end=" ")
#
# , то будут получены ЧИСЛА соответствующих СТРОК.
# То есть, здесь действительно функция map() последовательно применила функцию int()
# к КАЖДОМУ элементу списка и на выходе получаются уже обычные целые числа.
#
# Используя функцию list(), можно сохранить результат преобразования в новом списке:
#
# a = list(b)
# print(a)
#
# Здесь функция list() автоматически перебрала итератор, неявно вызывая функцию next(),
# и сформировала соответствующие значения списка.
# Этот же результат можно получить, используя генератор списка, следующим образом:
#
# a = [int(x) for x in ['1', '2', '3', '5', '7']]
# print(a)
#
# Но здесь, в отличие от функции map() все значения уже хранятся в памяти,
# тогда как функция map() возвращает итератор и значения формируются по одному в
# процессе вызова функции next().
#
# А ЭТО ЭКВИВАЛЕНТНЫЙ генератор:
#
# a = (int(x) for x in ['1', '2', '3', '5', '7'])
#












