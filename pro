"""
1. Выполнить задание уровня light
2. Придумать 2 теста к "грязной" функции. Примером "грязной" функции является
   функция F из дз 4;
3. Прислать ответ по инструкции 4.


ТЕОРИЯ... Что такое ЧИСТАЯ функция ============================================
Все функции надо стараться делать ЧИСТЫМИ:
такими, чтобы их результат зависел только от СВОИХ входных параметров и
возвращали только свой результат (НЕ имели side-effects, в частности,
не могли сломать другие функции).

Признаки чистой функции:
= не пишет в файловую систему;
= не пишет в stdout, stderr (print);
= не меняет глобальные переменные;
= не меняет аргументы, поданные на вход функции (edited);
= не меняет ход выполнения программы (не используют exit(), например);
= не использует внутри себя грязные функции;
= МОЖЕТ возбуждать исключения.

Достоинства чистых функций:
= безопасность. Потому что на результат работы функции ничего не влияет.
  В том числе, такие настройки системы как кодировка stdout (print).
= предсказуемость. В каком бы окружении не была запущена функция, результат будет один.
  Можно спокойно использовать и не бояться ошибки.
= тестируемость. Если результат зависит только от параметров, то тесты пишутся легко.
  Это очень важно.

И как же тогда выводить сообщение в консоль, когда надо распечатать значение КАКОЙ-ТО ФУНКЦИИ
или МЕТОДА, которые должны быть выполнены в соответствующих выражениях функции print,
если это выполнение может изменить значение переменных и состояние объекта, связанного
с этой функцией().
Надо стараться ЭТО делать путём размещения ввода/вывода внутри конструкции
if __name__ == '__main__' (!!!), либо внутри специальных функций вызываемых оттуда.
Все же остальные функции желательно сохранять чистыми.
Если обработать входные данные сложно - надо возвращать None или выкидывать исключение
с кодом/описанием ошибки. И пусть с этим разбирается вызывающая программа/функция.

Чистые и грязные функции (методы) =============================================

Если программа содержит функции, то это не обязательно означает, что это пример
функционального программирования.
Функциональное программирование различает ЧИСТЫЕ и ГРЯЗНЫЕ функции.
Это побуждает(!!!) писать чистые функции.
Чистая функция должна удовлетворять ОБОИМ из следующих свойств:

= Ссылочная прозрачность: функция всегда возвращает одинаковое значение для одинаковых аргументов.
  Это означает, что функция не может зависеть от любого ИЗМЕНЯЕМОГО состояния.
= Без побочных эффектов: функция не может вызывать побочных эффектов.
  Побочные эффекты могут включать в себя ввод-вывод (например, запись в консоль или файл журнала),
  изменение изменяемого объекта, переназначение переменной и т.д.

Примеры чистых функций.
Во-первых, функция умножения является примером чистой функции.
Она всегда возвращает один и тот же результат для одного и того же ввода и
не вызывает побочных эффектов.

def multiply(a, b):
  return a * b

А это примеры грязных функций. Функция canRide зависит от захваченной переменной
heightRequirement. Захваченные переменные не обязательно делают функцию грязной,
но изменяемые (или переназначаемые) делают. В этом случае heightRequirement
была объявлена с использованием let, что означает, что она может быть переназначена.
Функция multiply в этом примере грязная, потому что она вызывает побочный эффект
выводом в консоль.

# =============================================================================
heightRequirement = 46

# Нечистый, потому что он зависит от изменяемой (переназначаемой) переменной
# Impure because it relies on a mutable (reassignable) variable.
def canRide(height):
  return height >= heightRequirement

# Impure because it causes a side-effect by logging to the console.
def multiply(a, b):
  print(f'Arguments: {a}, {b}')
  return a * b

# =============================================================================

Несколько грязных функций (какие из свойств не работают ?)

Math.random
Date.now

Идеальный мир, в котором все функции чистые, был бы очень неплох, но,
любая значимая программа будет содержать грязные функции.
Так как нужно будет проверять текущую дату или получать случайное число.
Хорошее практическое правило – следовать правилу 80/20: 80% функций должны быть чистыми,
а оставшиеся 20% по необходимости (!!!) будут грязными.

несколько преимуществ для чистых функций:
= Их легче отлаживать, потому что они не зависят от изменяемого состояния.
= Возвращаемое значение может быть кэшировано или "запомнено", чтобы избежать
  его повторного вычисления в будущем.
= Их проще тестировать, потому что нет никаких зависимостей, которые необходимо проверять
  (таких, как ведение журнала, база данных и т.д.).

Если функция, которая пишется или используется, НЕ имеет возвращаемого значения,
это признак того, что она грязная.
Как правило это либо не операция, либо она вызывает некоторый побочный эффект.
Также, если вызывается функция, но НЕ ИСПОЛЬЗУЕТСЯ ее возвращаемое значение,
то существует вероятное, предположение, что возможно получение какого-то
побочного эффекта, и это грязная функция.

Неизменность
Назад к концепции захваченных переменных. Ранее была рассмотрена функция canRide.
Есть гипотеза, что это грязная функция, потому что heightRequirement может быть
переназначена. Вот пример того, как его можно переназначить с
непредсказуемыми результатами:

heightRequirement = 64
def canRide(height):
  return height >= heightRequirement

И с этим ничего нельзя сделать, так как в python нет
неизменяемых переменных (констант), поэтому на самом деле
объявляются не константы. Просто записываются переменные заглавными буквами,
чтобы отличать их от обычных, "изменяемых" переменных.
Но это не значит, что переназначить "константу" не получится.


    Неизменность в python относится ко всем структурам данных, включая массивы, map и set.
Это означает, что невозможно вызывать методы-мутаторы, такие как
array.prototype.push, потому что это изменяет существующий массив.
Вместо того, чтобы помещать элемент в существующий массив, можно создать
новый массив со всеми теми же элементами, что и исходный массив,
и ещё один дополнительный элемент. Это и будет означать размещение элемента в
неизменяемом массиве, то есть реализацию метода array.prototype.push.
    То же самое происходит при использовании Map или Set. Можно избежать использования
методов-мутаторов, возвращая новую Map или Set с желаемыми изменениями.
    Фактически, каждый метод мутатора может быть заменен функцией, которая возвращает
новый массив с желаемыми изменениями (!!!).
===============================================================================
python очень 'просто' читать, до тех пор, пока остаются
известными ТОЛЬКО ЕГО ОСНОВЫ и действительно нет никаких сомнений относительно того,
что делает код на языке python в любой момент времени.
НО, как и любой другой язык и его реализации, python имеет некоторые особенности.
(???) Что происходит под капотом...
А там - "нечистые" ("грязные") функции и методы

========== python: вопросы для обсуждения =====================================

Переменные, пространство имен и область действия
    Сфера
Удаление элемента списка во время итерации
    del ключевое слово
    remove() метод
    pop(idx) метод
Что работает?
Изменение словаря во время итерации по нему
Разрешение имени без учета области класса
Изменяемые аргументы по умолчанию
Same operands, different story
Что не так с логическими значениями?
Атрибуты класса и атрибуты объекта (экземпляра)
split() метод
Wild импорт

===============================================================================

Переменные, пространство имен и область действия
Когда речь идет о python изнутри, нужно говорить о двух вещах:
пространство имен и область видимости.

Пространство имен
В python, поскольку это объектно-ориентированный язык программирования,
всё считается объектом. Пространство имён — это просто контейнер для
сопоставления имени переменной объекта и этого объекта (сопоставить одно с другим).

function_namespace = { name_of_obj_a: obj_1, name_of_obj_b: obj_2 }
for_loop_namespace = { name_of_obj_a: obj_3, name_of_obj_b: obj_4 }

Можно рассматривать пространства имен просто как словари Python,
где имя переменной для объекта является ключом, а значение — самим объектом.
При определении цикла, функции или класса каждый раз создаётся новое независимое
пространство имен (!!!).
Каждое пространство имен имеет свою собственную иерархию, называемую областью действия.

Сфера
Область видимости на очень высоком уровне — это иерархия, в которой интерпретатор
python может "видеть" определенный объект.
Интерпретатор начинает с наименьшей области видимости, локальной, и смотрит наружу,
если не может найти объявленную переменную в закрытой области.
Если интерпретатор не может найти его в закрытой области видимости, он обращается
к глобальной области видимости.

Вот пример

i = 1
def namespaces():
   i = 5
   print(i, 'in namespaces()')
   print("local foo() namespace", locals())
   return i

print("global namespace", globals())

namespaces()

Здесь есть global пространство имен, и есть namespaces() пространство имен.
Можно увидеть отдельные пространства имен, распечатав globals()
и распечатав locals() в заданных местах кода.

Локальное пространство имен довольно простое. Видно и его значение.
Глобальное пространство имен отличается тем, что оно также включает
некоторые посторонние вещи из python.

Здесь функция namespaces отображается как место в памяти,
а не как фактическое значение функции, а также значение for i в global пространстве имен.
При этом можно изменить переменную в глобальном пространстве имен.
Просто надо применить ключевое слово global перед именем переменной i непосредственно
перед реализацией функции:

i = 1

def namespaces_1():
   global i
   i = 5
   print(i, 'in namespaces_1()')
   print('local namespace', locals())
   return i
print('global i before func invocation', globals()['i'])
namespaces()
print('global i after func invocation', globals()['i'])

Удаление элемента списка во время итерации ====================================
При работе со списками в python нужно смотреть, что происходит, когда удаляются
элементы из списка, когда он перебирается его в цикле.
Повторять и удалять элементы из списка не рекомендуется из-за непредвиденных последствий.
Вот такие примеры:

= del ключевое_слово
del ключевое_слово только удаляет экземпляр этого элемента в локальном
пространстве имен, но не фактический элемент сам по себе в глобальном пространстве имен.
Таким образом, глобально определенное list_1 не затронуто.

list_1 = ['apples', 'oranges', 'bananas', 'strawberries] # глобально определенное

for item in list_1:
   del item

print('list_1: ',list_1); # ['apples', 'oranges', 'bananas', 'strawberries']

= remove() метод
В этом remove() методе, как только python удаляет элемент из списка,
все остальные элементы сдвигаются влево один раз, но итерация не происходит до тех пор,
пока все не будет перемещены. Итерация означает увеличение индекса списка на 1.
Таким образом, после перемещения, под индексом 1 в списке удаляемых элементов,
оказывается  элемент 'bananas'. 'oranges' под новым перемещённым индексом 0 для
метода remove после итерации оказывается недостижимым.

list_2 = ['apples', 'oranges', 'bananas', 'strawberries']
for item in list_2:
   list_2.remove(item)

print('list_2: ',list_2) # ['oranges', 'strawberries']

Вот пошаговое описание того, как это происходит:

Первая итерация: удалить apples.
                         oranges перемещается влево и теперь является текущим индексом.
                         bananas перемещается влево и становится следующим индексом.
                         strawberries перемещается влево,
                         и цикл переходит к следующему индексу
                         (то есть, к индексу 2 вместо индекса 1, который после первой итерации
                         рказывается равным 0).
Вторая итерация: bananas находится в текущем индексе (индексе 1), поэтому удаляется bananas.
                 strawberries перемещается влево и теперь является текущим индексом (индекс 1).
                 Значений индекса в списке больше нет, поэтому итерация считается выполнена.
Результат: в списке останется два элемента: oranges и strawberries.

= pop(idx) метод
По той же причине, по которой не используется метод remove при просмотре списка,
не используется метод pop(idx). Если индекс не передается в качестве аргумента,
python удаляет последний индекс в списке.

list_3 = ['apples', 'oranges', 'bananas', 'strawberries']
for item in list_3:
   list_3.pop()
print('list_3:',list_3) # ['apples', 'oranges']

Первая итерация: удалить strawberries, поэтому длина списка теперь равна трем.
                 Перейти к следующей итерации.
Вторая итерация: удалить bananas, поэтому длина списка теперь равна двум.
                 Значений индекса больше нет, итерация выполнена.
Результат: останется apples и oranges в списке.
Примечание. Если в pop() метод передан индекс, но он не существует, он вызовет
            исключение IndexError.

Что работает?
Пребор и манипулировани списком в Python заключается в разрезании или
создании копии списка. Это так же просто, как использовать [:]

list_4 = ['apples', 'oranges', 'bananas', 'strawberries']

for item in list_4[:]:
      list_4.remove()  #pop() would also work here.

print('list_4: ',list_4) # []

list_4[:] Этот оператор делает копию списка в памяти. Исходный список НЕ изменяется,
когда при его копировании, но влияет на исходный, когда все готово.
# =============================================================================

Изменение словаря во время итерации по нему
Словари Python могут быть сложными объектами для работы.
Тем не менее, эти словари вообще не могут быть изменены, когда они зацикливаются.
Цикл будет выполняться определенное количество раз (от 4 до 8), пока не потребуется
изменить размер словаря.

Может быть обходной путь, используя составные части списков, но это не лучший вариант.

for i in x:
   del x[i]
   x[i+1] = i + 1
   print(i)
   print(x)


Разрешение имени без учета области класса =====================================

В python представлениям списков предоставлена собственная ограничивающая область.
Когда понимание(!!!) списка не находит определения для охватывающей области видимости,
Он обращается к глобальной области.
Вот почему в примере python игнорирует a = 17 в области видимости класса.

a = 5
class Example:
   # global a
   a = 17
   b = [a for i in range(20)]

print(Example.b[0])

Изменяемые по умолчанию аргументы =============================================
Аргументы по умолчанию в python — это резервные значения, которые устанавливаются как параметры,
если функция вызывается без аргументов. Они могут быть полезны, но если вызывать функцию
несколько раз подряд, могут возникнуть 'непредвиденные' последствия.


def num_list(nums=[]):
   num = 1
   nums.append(num)
   return nums

print(num_list())
print(num_list())
print(num_list([]))
print(num_list())
print(num_list([4]))


Same operands, different story ================================================
Переназначения в python. Как они работают.
Операторы = и += имеют два разных значения в python при их использовании в
сочетании со списками.

# reassignment
a = [1, 2, 3, 4]
b = a
a = a + [5, 6, 7, 8]
print(a)
print(b)
# extends
a = [1, 2, 3, 4]
b = a
a += [5, 6, 7, 8]
print(a)
print(b)

При манипулировании списками = оператор просто означает переназначение.
Когда b назначен как a, он создает копию того a, которое было в то время.
При переназначении a для a + [5, 6, 7, 8], + объединяет оригинал a с [5, 6, 7, 8]
to create [1, 2, 3, 4, 5, 6, 7, 8]. Список b остается неизменным от его
первоначального значения.

С += оператором, когда он относится к спискам, это ярлык для extends() метода.
Это приводит к тому, что список меняется на месте, давая [1, 2, 3, 4, 5, 6, 7, 8]
как a и b.

Что с логическими значениями? =================================================
Когда дело доходит до логических значений, это кажется довольно простым.
Сколько логических значений и сколько целых значений в таком смешанном массиве...

mixed_type_list = [False, 4.55, 'educative.io', 3, True, [], False, dict()]
integers_count = 0
booleans_count = 0
for item in mixed_type_list:
   if isinstance(item, int):
       integers_count += 1
   elif isinstance(item, bool):
       booleans_count += 1
print(integers_count)
print(booleans_count)

Почему на выходе 4-0? Логическое значение в Python является
подклассом целых чисел. Истина в Python приравнивается к 1, а ложь равняется 0.

Атрибуты класса и атрибуты экземпляра (объекта) ===============================
В объектно-ориентированном python класс — это шаблон, а экземпляр — это новый объект,
основанный на этом шаблоне. Что бы произошло, если попытаться изменить или смешать
присвоения переменных класса и переменных экземпляра?

class Animal:
   x = 'tiger'

class Vertebrate(Animal):
   pass

class Cat(Animal):
   pass

print(Animal.x, Vertebrate.x, Cat.x)
Vertebrate.x = 'monkey'
print(Animal.x, Vertebrate.x, Cat.x)
Animal.x = 'lion'
print(Animal.x, Vertebrate.x, Cat.x)
a = Animal()
print(a.x, Animal.x)
a.x += 'ess'
print(a.x, Animal.x)

Здесь имеимеются три класса: Animal, Vertebrate и Cat. Когда назначается
переменная в классе Animal, а другие классы являются расширениями класса Animal,
эти другие классы имеют доступ к переменной, созданной в классе Animal.
Нужно быть увереным в переназначении при работе с классами и экземплярами.
При изменении шаблона - использовать имя класса, при изменении экземпляра -
использовать переменную, которая была назначена новому экземпляру имени класса.

split() метод имеет уникальные свойства =======================================

x_string = " Apples! Oranges! Pears! Bananas, Berries "
  print(x_string.split("!"))

  print(' foo bar   '.split())  # ['foo', 'bar']
  print('»'.split('    '))  # [»] В строке нет такого разделителя

Когда методу разделения даётся  разделитель, в данном случае ('!'), и используется
его в строке любой длины, он будет разделен на пробелы. Независимо от того,
сколько пробелов в строке, он будет разделен на каждый из них.

Если разделитель не указан, интерпретатор Python сожмет все повторяющиеся пробельные
символы в один и разделит этот символ, оставив только группы непробельных символов
разделенными.

Пустая строка, разделенная на пробельный символ, вернет список с пустой строкой в
качестве первого индекса.

Wild импорт ===================================================================
Импорт подстановочных знаков может быть полезен, если известно, как их использовать.
У них есть некоторые особенности. Вот этот пример:

def hello_world(str):
   return str

def _hello_world(str):
   return str

from helpers import *
hello_world("hello world — WORKS!")
_hello_world("_hello_world — WORKS!")

Если попытаться запустить это в каталоге, в котором находились эти файлы,
первый вызов hello_world функции сработал бы нормально. Второй, не совсем.
При использовании импорта с подстановочными знаками функции, начинающиеся с подчеркивания,
не импортируются.

Для этих методов придется либо напрямую импортировать функцию, либо использовать
__all__список, чтобы использовать импорт с подстановочными знаками.

__all__ = [hello_world, _private_hello_world]

def hello_world(str):
   return str

def _private_hello_world(str):
   return str

Примечание:__all__ переменная окружена двумя символами подчеркивания с обеих сторон.

===============================================================================

Так вот наличие всего выше описанного (хлама...) делает функцию "нечистой".

НЕЧИСТЫЕ ФУНКЦИИ
= могут писать в файловую систему;
= могут писать в stdout, stderr (print);
= могут менять глобальные переменные;
= могут менять аргументы, поданные на вход функции (edited);
= могут менять ход выполнения программы (например, используют exit());
= могут использовать внутри себя грязные функции;
= МОГУТ (и что из того?) возбуждать исключения.

Существует такое негласное(!!!) соглашение. По умолчанию все функции считаются чистыми.
Если кто-то использует ранее написанную кем-то функцию (например встроенную),
то он исходит из того что она чистая, если явно не будет указано обратного в её названии.
Если без "грязной" функции не обойтись - надо использовать в её названии слова
print, write, save и пр. (слова ассоциирующиеся с операциями ввода/вывода).
И никогда не надо мешать в одной функции ввод/вывод с нетривиальной обработкой данных,
которые надо всегда разносить.

===============================================================================


"""
from random import randint
from functools import reduce
import unittest

numbers = [2, 3, 8]

# В python представлениям списков предоставлена собственная ограничивающая область.
# Когда понимание(!!!) списка не находит определения для охватывающей области видимости,
# Он обращается к глобальной области.
# Вот почему Python 3 в этом примере в области видимости класса игнорирует a = 17.

def extracters():
# = del ключевое слово
# del Ключевое слово только удаляет экземпляр этого элемента в локальном
# пространстве имен, но не фактический элемент сам по себе в глобальном пространстве имен.
# Таким образом, глобально определенное list_1 не затронуто.

    list_1 = ["apples", "oranges", "bananas", "strawberries"]
    for item in list_1:
       del item
    print("list_1:", list_1) # ["apples", "oranges", "bananas", "strawberries"]

# = remove() метод
# В этом remove() методе, как только Python удаляет элемент из списка,
# все остальные элементы сдвигаются влево один раз, но итерация не происходит до тех пор,
# пока все не будет перемещено.

    list_2 = ["apples", "oranges", "bananas", "strawberries"]
    for item in list_2:
        list_2.remove(item)
    print("list_2:" , list_2)# ["oranges", "strawberries"]

i = 1

def namespaces():
   i = 5
   print(i, 'in namespaces()')
   print("local namespaces() namespace", locals())
   return i


def namespaces_1():
   global i
   i = 5
   print(i, 'in namespaces_1()')
   print('local namespace', locals())
   return i

a = 5  # ГЛОБАЛЬНАЯ область видимости для class Example0.
# для class Example1 операция a = 5 во ВНЕШНЕЙ области видимости игрорируется.

class Example0:
   #global a
   a = 17  # область видимости класса.
           # Но также есть ГЛОБАЛЬНАЯ область видимости. В ней a = 5
   b = [a for i in range(20)]

class Example1:
   global a  # а здесь из собственной ограничивающей области видимости класса.
   # САМА объявлена как ГЛОБАЛЬНАЯ. Поэтому операция a = 5 во ВНЕШНЕЙ области
   # видимости игрорируется
   a = 17  # а эта переменная не используется
   b = [a for i in range(20)]

class Example2:
    # А здесь нет глобальных объявлений. Ни собственной ограничивающей
    # области видимости класса, ни во ВНЕШНЕЙ области
    # И оно берётся из БЛИЖАЙШЕГО подходящего объявления класса
    a = 125
    b = [a for i in range(20)]

class Example3:
   # а здесь нет глобальных объявлений. Ни собственной ограничивающей
   # области видимости класса, ни во ВНЕШНЕЙ области
   #a = 125     # Здесь ВООБЩЕ нет объявления a !!!
   # И оно берётся из БЛИЖАЙШЕГО подходящего объявления класса
   b = [a for i in range(20)]

class Example4:
    aaa = 777  # !!!
    bbb = []

    # здесь нет глобальных объявлений. Есть собственная ограничивающая
    # область видимости класса, в которой aaa и bbb присваиваются значения.
    # Здесь объявлена и проинициализирована новая переменная!!!
    # И для неё нет значения БЛИЖАЙШЕГО подходящего объявления класса.
    # Кроме того, здесь не получилось написать генератор списка для bbb,
    # поэтому пришлось инициализировать в цикле (в чём вопрос - непонятно)
    for aaa in range(0):
        bbb.append(aaa)

# =============================================================================
# ИЗМЕНЯЕМЫЕ аргументы по умолчанию. Это резервные значения, которые
# устанавливаются как параметры, если функция вызывается без аргументов.
# Если вызывать такую функцию несколько раз подряд с аргументами по умолчанию,
# то могут возникнуть 'непредвиденные' последствия. Например, измеменение значения
# аргумента по умолчанию.
def defaultOptionsExample(nums=[]):
    print(nums)
    num = 1
    nums.append(num)
    print(nums)
    return nums

def simpleOptionsExample(nums):
    print(nums)
    num = 1
    nums.append(num)
    print(nums)
    return nums


def doIt():

    print(defaultOptionsExample(), end='\n\n')
    # ИЗМЕНЯЕМЫЙ пустой список по умолчанию. Туда добавился элемент
    print(defaultOptionsExample(), end='\n\n')
    # ИЗМЕНЯЕМЫЙ список по умолчанию СОДЕРЖИТ элемент, и это не смотря на его вызов
    print(defaultOptionsExample([]), end='\n\n')
    # вызов функции с аргументом, который изменяет ИЗМЕНЯЕМЫЙ аргумент по умолчанию
    print(defaultOptionsExample(), end='\n\n')
    # опять вызов функции с аргументом по умолчанию, в возвращённом списке ТРИ(!!!) элемента
    print(defaultOptionsExample([9]), end='\n\n')
    # вызов функции с аргументом, который изменяет ИЗМЕНЯЕМЫЙ аргумент по умолчанию. Это непустой список

    # а тут вроде ничего НЕПРЕДВИДЕННОГО не происходит.
    print(simpleOptionsExample([]), end='\n\n')
    # ИЗМЕНЯЕМЫЙ пустой список. Туда добавился элемент
    print(simpleOptionsExample([1]), end='\n\n')
    # ИЗМЕНЯЕМЫЙ список по умолчанию СОДЕРЖИТ элемент, и это не смотря на его вызов
    ret = simpleOptionsExample([1,2,3,4,5])
    print(ret, end='\n\n')
    print(simpleOptionsExample(ret), end='\n\n')
    # вызов функции с аргументом, который изменяет ИЗМЕНЯЕМЫЙ аргумент по умолчанию
    print(simpleOptionsExample([]), end='\n\n')
    # опять вызов функции с аргументом по умолчанию, в возвращённом списке ТРИ(!!!) элемента
    print(simpleOptionsExample(simpleOptionsExample([])), end='\n\n')
    # вызов функции с аргументом, который изменяет ИЗМЕНЯЕМЫЙ аргумент по умолчанию. Это непустой список

    # два вызова функции с ИЗМЕНЯЕМЫМ аргументом по умолчанию выполняются с разным результатом
    if list(defaultOptionsExample()) == list(defaultOptionsExample()):
        print('OK')
    else:
        print('NO')

    # если при вызове функции с ИЗМЕНЯЕМЫМ аргументом по умолчанию передать
    # ОДНО И ТО ЖЕ значение, будет получен один и тот же результат
    if list(defaultOptionsExample([125])) == list(defaultOptionsExample([125])):
        print('OK')
    else:
        print('NO')

    # два вызова функции с ПРОСТЫМ (не по умолчанию) аргументом выполняются
    # с одним результатом. Если, конечно, у них при вызове одинаковые значения аргумента
    if list(simpleOptionsExample([1,2,3,4,5])) == list(simpleOptionsExample([1,2,3,4,5])):
        print('OK')
    else:
        print('NO')

    if list(simpleOptionsExample([1,2,3,4])) == list(simpleOptionsExample([1,2,3,4,5])):
        print('OK')
    else:
        print('NO')
    print('\n-----=============Example0-Example4===========-----\n')
    print(Example0.b[0], end=' Example0\n')
    print(Example1.b[0], end=' Example1\n')
    print(Example2.b[0], end=' Example2\n')
    print(Example3.b[0], end=' Example3\n')
    print(Example4.aaa, end=' Example4\n')
    print(Example4.aaa, end=' Example4\n')
    print('=====================================================\n')


def get_maximum(first_num, second_num):
    return first_num if first_num > second_num else second_num

# ========================================================================
def is_even(num):
  return num % 2 == 0

# Эта функция сделана ПОД ЛЮБУЮ, подходящую для обработки
# списка фильтром функцию. Список также может быть ЛЮБЫМ.
# при таких условиях такая функция однозначно "нечистая" ("грязная")
def filterLstGenerator(fun, lst):
  retLst = list(filter(fun, lst))
  print(f'lstGenerator: {retLst}')
  return retLst
# ========================================================================
#
# # списки случайных чисел в диапазоне от 0 до 10
# # длиной в 10 элементов: создаётся список из 10 единиц,
# # каждый из которых умножается на случайное число
# argList_0 = [int(x*randint(0, 10)) for x in [1]*10]
# print(argList_0)
# argList_1 = [int(x*randint(0, 10)) for x in [1]*10]
# print(argList_1)
#
# # ранее определённые списки фильтруются
# l0 = list(filter(is_even, argList_0))
# print(l0)
# l1 = list(filter(is_even, argList_1))
# print(l1)
#
# # и сравниваются
# if l0 == l1:
#   print('lists l1 and l2 are equal')
# else:
#   print('lists l1 and l2 are not equal')
#
#
# # тестовый запуск функции-генератора
# filterLstGenerator(is_even, argList_0)
#
#
# # Этот класс предполагалось использовать для создания объекта,
# # в котором бы применялись только методы базового класса.
# # class lstEq(unittest.TestCase):
# #   res = False
#
# #objComparator = lstEq()
#
# # Но здесь действительно важен только класс TestCase из модуля unittest
# # и ничего больше. Поэтому не надо объявлять 'лишние' классы для применения
# # методов, объявленных в базовом классе.
# objComparator = unittest.TestCase()
#
# try:
#   objComparator.assertEqual(filterLstGenerator(is_even, argList_0),
#                             filterLstGenerator(is_even, argList_1), "\ntestPowers is not correct")
# except Exception as ex:
#   print(ex)
# else:
#   print("OK, testPowers passed")


def funExamples():
    doIt()
    # reduce(get_maximum, numbers, 10)  # 10
    # reduce(get_maximum, numbers)  # 8
    namespaces()
    print("global namespace", globals())
    print('**********')
    print('global i before func invocation', globals()['i'])
    namespaces_1()
    print('global i after func invocation', globals()['i'])
    print('----- extracters -----')
    extracters()

    # =========================================================================
    # списки случайных чисел в диапазоне от 0 до 10
    # длиной в 10 элементов: создаётся список из 10 единиц,
    # каждый из которых умножается на случайное число
    argList_0 = [int(x * randint(0, 10)) for x in [1] * 10]
    print(argList_0)
    argList_1 = [int(x * randint(0, 10)) for x in [1] * 10]
    print(argList_1)

    # ранее определённые списки фильтруются
    l0 = list(filter(is_even, argList_0))
    print(l0)
    l1 = list(filter(is_even, argList_1))
    print(l1)

    # и сравниваются
    if l0 == l1:
        print('lists l1 and l2 are equal')
    else:
        print('lists l1 and l2 are not equal')

    # тестовый запуск функции-генератора
    filterLstGenerator(is_even, argList_0)

    # Этот класс предполагалось использовать для создания объекта,
    # в котором бы применялись только методы базового класса.
    # class lstEq(unittest.TestCase):
    #   res = False

    # objComparator = lstEq()

    # Но здесь действительно важен только класс TestCase из модуля unittest
    # и ничего больше. Поэтому не надо объявлять 'лишние' классы для применения
    # методов, объявленных в базовом классе.
    objComparator = unittest.TestCase()

    try:
        objComparator.assertEqual(filterLstGenerator(is_even, argList_0),
                                  filterLstGenerator(is_even, argList_1),
                                  "\ntestObjComparator is not correct")
    except Exception as ex:
        print(ex)
    else:
        print("OK, testObjComparator passed")
    # =========================================================================

def start(descrption):
    print(f'pro start {descrption}\n')
    funExamples()

# start('XXX')



